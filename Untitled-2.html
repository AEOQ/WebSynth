<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Audio API: All Processing Nodes Demo</title>
    <link rel="stylesheet" href="synth.css">
    <script src="//aeoq.github.io/drag-knob/script.js" type="module"></script>
    <style>
        continuous-knob:not([title])::before {
            content: attr(name);
        }
        continuous-knob::before {
            text-transform: capitalize;
        }
    </style>
</head>
<body>
    <form>
        <fieldset name="Oscillator">
            <legend>Wave</legend>
            <discrete-knob name="type" list='["sine","sawtooth","square","triangle"]' value="square" title="Form"></discrete-knob>
        </fieldset>
        <fieldset name="Envelope">
            <legend>Envelope</legend>
            <continuous-knob name="A" max="5" step="0.01" value="1" unit="s"></continuous-knob>
            <continuous-knob name="D" max="5" step="0.01" value="1" unit="s"></continuous-knob>
            <continuous-knob name="S" min="0.001" max="1" step="0.001" value="1"></continuous-knob>
            <continuous-knob name="R" max="5" step="0.01" value="1" unit="s"></continuous-knob>
        </fieldset>
        <fieldset name="BiquadFilter">
            <legend>Biquad Filter</legend>
            <discrete-knob name="type" list='["lowpass","highpass","bandpass","lowshelf","highshelf","peaking","notch","allpass"]' title="Type"></discrete-knob>
            <continuous-knob name="frequency" min="100" max="5000" step="100" value="800" unit="Hz" title="Freq"></continuous-knob>
            <continuous-knob name="detune" min="-100" max="100"></continuous-knob>
            <continuous-knob name="Q" max="100"></continuous-knob>
            <continuous-knob name="gain" max="10"></continuous-knob>
        </fieldset>
        <fieldset name="DynamicsCompressor">
            <legend>Compressor</legend>
            <continuous-knob name="threshold" min="-100" max="0" value="-50" unit="dB"></continuous-knob>
            <continuous-knob name="knee" min="0" max="40" value="40" unit="dB"></continuous-knob>
            <continuous-knob name="ratio" min="1" max="20" value="12"></continuous-knob>
            <continuous-knob name="attack" max="5" step="0.01" value="0" unit="s"></continuous-knob>
            <continuous-knob name="release" max="5" step="0.01" value="0.25" unit="s"></continuous-knob>
        </fieldset>
        <fieldset name="Delay">
            <legend>Delay</legend>
            <continuous-knob name="delayTime" max="2" step="0.01" value="0.1" unit="s" title="Time"></continuous-knob>
        </fieldset>
        <fieldset name="StereoPanner">
            <legend>Stereo Panner</legend>
            <continuous-knob name="pan" min="-1" max="1" step="0.1" value="0"></continuous-knob>
        </fieldset>
        <input type="checkbox" name="visualize">Spectrum
    </form>
    <canvas width="800" height="400"></canvas>
</body>
<script type="module">
    import {A,E,O,Q} from '//aeoq.github.io/AEOQ.mjs';
    let Notes = new Map();
    const Controls = name => {
        if (Array.isArray(name))
            return new O(name.map(n => [n, Controls(n)]));
        let el = document.forms[0][name];
        return el?.tagName == 'FIELDSET' ?
            new O([...el.elements ?? []].map(({name, value}) => [name, parseFloat(value) || value])) :
            parseFloat(el?.value) || el?.value;
    }
    class Nodes {
        constructor(all) {
            Nodes.context();
            new O(all).each(([type, options]) => this[type] = new Node(type, options));
            return this;
        }
        connect (...ns) {
            for (let i = 1; i <= ns.length; i++) {
                if (i == ns.length) 
                    return this[ns[i - 1]].connect(Nodes.ctx.destination) && this;
                if (Array.isArray(ns[i]))
                    ns[i].forEach(params => this[ns[i - 1]].connect(...params.map(p => typeof p == 'string' ? this[p] : p)));
                else if (Array.isArray(ns[i - 1]))
                    this[ns[i - 1][0][0]].connect(this[ns[i]]);
                else 
                    this[ns[i - 1]].connect(this[ns[i]]);
            }
        }
        start () {
            this.Oscillator.start();
            Node(this.Gain, {envelope: {now: Nodes.ctx.currentTime, ...Controls(['A','D','S'])}});
            Visualizer(this.Analyser, Q('[name=visualize]').checked ? 'spectrum' : 'wave');
            return this;
        }
        stop () {
            Node(this.Gain, {envelope: {now: Nodes.ctx.currentTime, R: Controls('R')}});
            this.Oscillator.stop(Nodes.ctx.currentTime + 5);
            return this;
        }
        static context = () => (!Nodes.ctx || Nodes.ctx.state == 'closed') && (Nodes.ctx = new AudioContext());
    }
    const Node = function(typeORnode, options) {
        options = {
            ...options ?? {},
            ...Controls(typeof typeORnode == 'string' ? typeORnode : typeORnode.constructor.name.replace('Node', ''))
        };
        if (typeof typeORnode == 'string') 
            return new window[`${typeORnode}Node`](Nodes.ctx, options);

        Object.entries(options).forEach(([p, v]) => {
            if (p == 'envelope') {
                typeORnode.gain.cancelScheduledValues(v.now);
                v.R != null ?
                    typeORnode.gain.exponentialRampToValueAtTime(0.0001, v.now + v.R) :
                    typeORnode.gain.setValueAtTime(0, v.now)
                        .linearRampToValueAtTime(1, v.now + v.A)
                        .exponentialRampToValueAtTime(v.S, v.now + v.A + v.D);
            } else
                typeof v == 'object' ? Object.assign(node[p], v) :
                typeof v == 'number' ? typeORnode[p].value = v : typeORnode[p] = v;
        });
        return typeORnode;
    }
    addEventListener('keydown', ev => {
        if (ev.key != ' ' || Notes.has(440)) return;

        Nodes.context();
        const impulseLength = Math.floor(Nodes.ctx.sampleRate * 0.05); // 50ms
        const impulse = Nodes.ctx.createBuffer(2, impulseLength, Nodes.ctx.sampleRate);
        for (let channel = 0; channel < 2; channel++) {
            const sampleData = impulse.getChannelData(channel);
            for (let i = 0; i < impulseLength; i++) {
                sampleData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 2);
            }
        }
        Notes.set(440, new Nodes({
            Oscillator: {frequency: 440},
            Gain: {gain: 0},
            BiquadFilter: {},
            IIRFilter: { 
                feedforward: new Float32Array([1]), 
                feedback: new Float32Array([-1.779, 0.817])
            },
            WaveShaper: { 
                curve: new Float32Array([...Array(101)].map((_, i) => Math.tanh(2 * (i / (101 - 1) * 2 - 1)))) 
            },
            DynamicsCompressor: {},
            Delay: {},
            Convolver: {buffer: impulse},
            ChannelSplitter: { numberOfOutputs: 2 },
            ChannelMerger: { numberOfInputs: 2 },
            Panner: {
                panningModel: 'HRTF',
                distanceModel: 'inverse',
                refDistance: 1,
                maxDistance: 10000,
                rolloffFactor: 1,
                coneInnerAngle: 360,
                coneOuterAngle: 0,
                coneOuterGain: 0,
                positionX: 1,
                positionY: 0,
                positionZ: -1
            },
            StereoPanner: {},
            Analyser: {}
        }).connect(
            'Oscillator', 'Gain', 
            'BiquadFilter', 'IIRFilter', 'WaveShaper', 'DynamicsCompressor', 
            'Delay', /*'Convolver',*/ 'ChannelSplitter', [['ChannelMerger', 0, 0],['ChannelMerger', 1, 1]], 
            /*'Panner',*/ 'StereoPanner', 'Analyser'
        ).start());
        // Connect chain: osc → gain → biquad → iir → waveshaper → compressor → delay → convolver → splitter → merger → panner → stereoPanner → destination
    });
    addEventListener('keyup', ev => ev.key == ' ' && Notes.get(440).stop() && Notes.delete(440));

    const Visualizer = (analyser, type) => {
        const canvas = Q('canvas');
        Object.assign(Visualizer, {
            width: canvas.width, height: canvas.height,
            ctx: canvas.getContext('2d')
        });
        if (type) {
            Visualizer.ctx.clearRect(0, 0, Visualizer.width, Visualizer.height);
            Visualizer[type](analyser);
        }
    }
    Object.assign(Visualizer, {
        wave: function(analyser, data) {
            data ??= new Uint8Array(analyser.fftSize = 2048);
            requestAnimationFrame(() => this.wave(analyser, data));

            analyser.getByteTimeDomainData(data);
            this.ctx.fillStyle = E(Q('html')).get('--bg');
            this.ctx.fillRect(0, 0, this.width, this.height);

            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = "white";
            this.ctx.beginPath();
            data.forEach((d, i) => 
                this.ctx[i ? 'lineTo' : 'moveTo'](i * this.width / data.length, d / 128 * this.height / 2)
            );
            this.ctx.lineTo(this.width, this.height / 2);
            this.ctx.stroke();
        },
        spectrum: function(analyser, data) {
            analyser.fftSize = 256;
            data ??= new Uint8Array(analyser.frequencyBinCount);
            requestAnimationFrame(() => this.spectrum(analyser, data));

            analyser.getByteFrequencyData(data);
            this.ctx.fillStyle = E(Q('html')).get('--bg');
            this.ctx.fillRect(0, 0, this.width, this.height);

            const barWidth = (this.width / data.length) * 2.5;
            data.forEach((d, i) => {
                this.ctx.fillStyle = `hsl(${d + 100},80%,50%)`;
                this.ctx.fillRect(i * (barWidth + 1), this.height - d / 2, barWidth, d / 2);
            });
        }
    });
</script>
</html>