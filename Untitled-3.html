<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Audio API: All Processing Nodes Demo with ADSR Envelope</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
        }
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }
        #status {
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Web Audio API: Utilizing All Audio Processing Nodes with ADSR Envelope</h1>
    <p>This demo chains a single oscillator through all major Web Audio API processing nodes that affect audio output, using minimal resources (one oscillator, simple buffers/curves). Now includes a repeating ADSR envelope on the gain for dynamic volume shaping.</p>
    <p>Nodes used: OscillatorNode, GainNode (with ADSR), BiquadFilterNode, IIRFilterNode, WaveShaperNode, DynamicsCompressorNode, DelayNode, ConvolverNode, ChannelSplitterNode, ChannelMergerNode, PannerNode, StereoPannerNode.</p>
    <p>ADSR: Attack=0.1s to 0.05, Decay=0.2s to 0.03 (sustain), Sustain=0.8s, Release=0.3s to 0. Note repeats every 1.4s.</p>
    <button id="startBtn">Start Audio</button>
    <button id="stopBtn" disabled>Stop Audio</button>
    <div id="status">Click Start to begin.</div>

    <script>
        let audioCtx;
        let osc;
        let gain;
        let isPlaying = false;
        let envelopeInterval;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');

        function applyEnvelope() {
            if (!isPlaying) return;
            const now = audioCtx.currentTime;
            const attackTime = 0.1;
            const decayTime = 0.2;
            const sustainLevel = 0.03;
            const sustainDuration = 0.8;
            const releaseTime = 0.3;
            const noteDuration = attackTime + decayTime + sustainDuration + releaseTime;

            // Cancel previous schedules and reset to 0
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(0, now);

            // Attack: ramp to peak (0.05)
            gain.gain.linearRampToValueAtTime(0.05, now + attackTime);

            // Decay: ramp to sustain level
            gain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);

            // Sustain: hold at sustain level
            gain.gain.setValueAtTime(sustainLevel, now + attackTime + decayTime);

            // Release: ramp to 0 after sustain
            gain.gain.linearRampToValueAtTime(0, now + attackTime + decayTime + sustainDuration + releaseTime);

            // Schedule next envelope
            envelopeInterval = setTimeout(applyEnvelope, noteDuration * 1000);
        }

        startBtn.addEventListener('click', async () => {
            if (isPlaying) return;

            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                await audioCtx.resume();

                // Single oscillator source (sine wave at 440 Hz)
                osc = new OscillatorNode(audioCtx, { type: 'sine', frequency: 440 });

                // GainNode (volume control, starts at 0 for envelope)
                gain = new GainNode(audioCtx, { gain: 0 });

                // BiquadFilterNode (lowpass filter)
                const biquadFilter = new BiquadFilterNode(audioCtx, { type: 'lowpass', frequency: 800 });

                // IIRFilterNode (approximate lowpass with coefficients)
                const feedforward = new Float32Array([1]);
                const feedback = new Float32Array([-1.779, 0.817]);
                const iirFilter = new IIRFilterNode(audioCtx, { feedforward, feedback });

                // WaveShaperNode (mild distortion via tanh curve)
                const waveShaper = new WaveShaperNode(audioCtx);
                const curveLength = 101;
                const curve = new Float32Array(curveLength);
                for (let i = 0; i < curveLength; i++) {
                    const x = (i / (curveLength - 1)) * 2 - 1;
                    curve[i] = Math.tanh(x * 2);
                }
                waveShaper.curve = curve;

                // DynamicsCompressorNode (compression)
                const compressor = new DynamicsCompressorNode(audioCtx, {
                    threshold: -50,
                    knee: 40,
                    ratio: 12,
                    attack: 0,
                    release: 0.25
                });

                // DelayNode (echo)
                const delay = new DelayNode(audioCtx, { delayTime: 0.1, maxDelayTime: 0.5 });

                // ConvolverNode (simple reverb impulse: short decaying noise)
                const convolver = new ConvolverNode(audioCtx);
                const impulseLength = Math.floor(audioCtx.sampleRate * 0.05); // 50ms
                const impulse = audioCtx.createBuffer(2, impulseLength, audioCtx.sampleRate);
                for (let channel = 0; channel < 2; channel++) {
                    const sampleData = impulse.getChannelData(channel);
                    for (let i = 0; i < impulseLength; i++) {
                        sampleData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 2);
                    }
                }
                convolver.buffer = impulse;

                // ChannelSplitterNode and ChannelMergerNode (split mono to stereo, merge back)
                const splitter = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });
                const merger = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });

                // PannerNode (3D spatial positioning)
                const panner = new PannerNode(audioCtx, {
                    panningModel: 'HRTF',
                    distanceModel: 'inverse',
                    refDistance: 1,
                    maxDistance: 10000,
                    rolloffFactor: 1,
                    coneInnerAngle: 360,
                    coneOuterAngle: 0,
                    coneOuterGain: 0,
                    positionX: 1,
                    positionY: 0,
                    positionZ: -1
                });

                // StereoPannerNode (2D panning)
                const stereoPanner = new StereoPannerNode(audioCtx, { pan: 0.2 });

                // Connect chain: osc → gain → biquad → iir → waveshaper → compressor → delay → convolver → splitter → merger → panner → stereoPanner → destination
                osc.connect(gain);
                gain.connect(biquadFilter);
                biquadFilter.connect(iirFilter);
                iirFilter.connect(waveShaper);
                waveShaper.connect(compressor);
                compressor.connect(delay);
                delay.connect(convolver);
                convolver.connect(splitter);
                splitter.connect(merger, 0, 0); // Left channel
                splitter.connect(merger, 1, 1); // Right channel (duplicated from mono)
                merger.connect(panner);
                panner.connect(stereoPanner);
                stereoPanner.connect(audioCtx.destination);

                osc.start();
                //applyEnvelope(); // Start the envelope loop
                isPlaying = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                status.textContent = 'Audio playing through all nodes with repeating ADSR envelope. You should hear a pulsing, processed 440Hz tone.';
            } catch (err) {
                status.textContent = 'Error starting audio: ' + err.message;
            }
        });

        stopBtn.addEventListener('click', () => {
            if (!isPlaying) return;
            if (envelopeInterval) {
                clearTimeout(envelopeInterval);
                envelopeInterval = null;
            }
            gain.gain.cancelScheduledValues(audioCtx.currentTime);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            osc.stop();
            if (audioCtx) audioCtx.close();
            isPlaying = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            status.textContent = 'Audio stopped.';
        });
    </script>
</body>
</html>